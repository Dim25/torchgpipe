#MODIFIED BY TORCHGPIPE
from typing import Any, Callable, Iterable, Iterator, Optional, Tuple, TypeVar

from torch import Tensor, device


TModule = TypeVar('TModule', bound=Module)
T1 = TypeVar('T1')
T2 = TypeVar('T2')
T3 = TypeVar('T3')

__Hook1 = Callable[[TModule, T1], T2]
__Hook2 = Callable[[TModule, T1, T2], T3]

class __RemovableHandle:
    # torch.utils.hooks.RemovableHandle
    def remove(self) -> None: ...


class Parameter(Tensor):
    def __new__(cls,
                data: Optional[Tensor] = None,
                requires_grad: bool = True,
                ) -> Parameter: ...


class Module:
    training: bool

    def __init__(self) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

    def to(self, device: device) -> Module: ...
    def apply(self, fn: Callable[[Module], None]) -> Module: ...

    def register_buffer(self, name: str, tensor: Tensor) -> None: ...
    def register_parameter(self, name: str, param: Parameter) -> None: ...

    def register_backward_hook(self, hook: __Hook2) -> __RemovableHandle: ...
    def register_forward_pre_hook(self, hook: __Hook1) -> __RemovableHandle: ...
    def register_forward_hook(self, hook: __Hook2) -> __RemovableHandle: ...

    def named_children(self) -> Iterable[Tuple[str, Module]]: ...
    def add_module(self, name: str, module: Module) -> None: ...


class Sequential(Module):
    def __init__(self, *args: Module) -> None: ...

    def __iter__(self) -> Iterator[Module]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Module: ...

    def forward(self, input: Any) -> Any: ...


class ModuleList(Module):
    def __init__(self, modules: Iterable[Module]) -> None: ...

    def __iter__(self) -> Iterator[Module]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Module: ...

#END
